<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <script src="closures.js"></script>
   <link href="base.css" rel="stylesheet" type="text/css">
   <title>Closures</title>
</head>
<body>
   <h1>Closures</h1>
   <p>
      The ability to access a parent level scope from a child level scope even after the parent function has been terminated.  
   </p>

   <pre>
      <code>
         function outer() {
            const outerVar = "Hey I am the outer Var!";
            function inner() {
               const innerVar = "I am an inner Var!";
               console.log(innerVar);
               console.log(outerVar);
            }
         }
      </code>
   </pre>


   <p>
      The look up chain won't find a variable called "outerVar" so it will go up one level until it finds the variable.  
   </p>

   <p>
      By calling out the functions, we can confirm this:
   </p>

   <pre>
      <code>
         function outer() {
            const outerVar = "Hey I am the outer Var!";
            function inner() {
               const innerVar = "I am an inner Var!";
               console.log(innerVar);
               console.log(outerVar);
            }
            inner();
         }
         outer();
      </code>
   </pre>

   <p>
      Closure comes into play when the functions are called outside the "outer()" function. 
   </p>


   <pre>
      <code>
         function outer() {
            const outerVar = "Hey I am the outer Var!";
            function inner() {
               const innerVar = "I am an inner Var!";
               console.log(innerVar);
               console.log(outerVar);
            }
            return inner;
         }
         
         const innerFn = outer();
         inner();
      </code>
   </pre>

   <p>
      We run the outer function which creates a variable, the inner function returns. 
   </p>

   <p>
      Examples 1:
   </p>

   <pre>
      <code>
         function createGreeting(greeting = '') {
         }
      </code>
   </pre>

   <p>
      Creapting a function called createGreeting that will take a greeting of nothing.  
   </p>


   <pre>
      <code>
         function createGreeting(greeting = '') {
            const myGreet = greeting.toUpperCase();
         }
      </code>
   </pre>

   <p>
      Then we will create a variable "myGreet" that will take the greeting that was passed in and run .toUpperCasc().  
   </p>


   <pre>
      <code>
         function createGreeting(greeting = '') {
            const myGreet = greeting.toUpperCase();
            return function (name) {
               return `${myGreet} ${name}`;
            }
         }
      </code>
   </pre>


   <p>
      Then we return a function, we don't have to name it. We are taking a person's name.  Then we return the greeting and the person's name.  
   
      Created 2 functions because we can create function based of which ever greeting we like.  
   </p>

   <pre>
      <code>
         const sayHello = createGreeting('Hello'); 
         const sayHey = createGreeting('Hey');
         console.log(sayHello('Jose'));
         console.log(sayHello('George'));
         console.log(sayHey('George'));
      </code>
   </pre>

   <p>
      We created the variable "myGreet" inside of the function "creaeGreeting". The variable can be accessed at a lower scope. The act of referencing the variable at a lower scope is called a closure, even after the variable has been closed over. 
   </p>

   <p>
      Example 2: 
   </p>


   <pre>
      <code>
         function createGame(gameName) {
            let score = 0;
            return function win() {
               score ++;
               return `Your name ${gameName} scoare is ${score}`;
            }
         }
      </code>
   </pre>

   
</body>
</html>